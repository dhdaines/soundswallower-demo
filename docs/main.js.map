{"version":3,"file":"main.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA,oBAAoB,mBAAO,CAAC,4EAAgB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,8BAA8B,gBAAgB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;AC3GA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UChDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;;;;;;;;;;ACrBa;AACb;AACA;AACA;AACA;;AAEA,mBAAO,CAAC,0DAAS;AACjB,mBAAO,CAAC,oCAAa;;AAErB,yBAAyB,mBAAO,CAAC,wEAAmB;;AAEpD;AACA;;AAEA;AACA,gBAAgB,OAAO,mBAAO,CAAC,sCAAc;AAC7C,WAAW,mBAAO,CAAC,0CAAgB;AACnC,UAAU,mBAAO,CAAC,wCAAe;AACjC,aAAa,QAAQ,mBAAO,CAAC,wCAAe;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mEAAmE,MAAM,MAAM,MAAM,MAAM;AAC3F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA,4BAA4B,uIAAgD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6GAAkC;AAC1D;AACA,UAAU,gDAAgD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://soundswallower-demo/./node_modules/purecss/build/pure-min.css?a0db","webpack://soundswallower-demo/./src/index.css?c40d","webpack://soundswallower-demo/./node_modules/webworker-promise/src/index.js","webpack://soundswallower-demo/./node_modules/webworker-promise/src/tiny-emitter.js","webpack://soundswallower-demo/webpack/bootstrap","webpack://soundswallower-demo/webpack/runtime/get javascript chunk filename","webpack://soundswallower-demo/webpack/runtime/global","webpack://soundswallower-demo/webpack/runtime/hasOwnProperty shorthand","webpack://soundswallower-demo/webpack/runtime/make namespace object","webpack://soundswallower-demo/webpack/runtime/publicPath","webpack://soundswallower-demo/webpack/runtime/jsonp chunk loading","webpack://soundswallower-demo/./src/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","const TinyEmitter = require('./tiny-emitter');\n\nconst MESSAGE_RESULT = 0;\nconst MESSAGE_EVENT = 1;\n\nconst RESULT_ERROR = 0;\nconst RESULT_SUCCESS = 1;\n\nclass Worker extends TinyEmitter {\n  /**\n   *\n   * @param worker {Worker}\n   */\n  constructor(worker) {\n    super();\n\n    this._messageId = 1;\n    this._messages = new Map();\n\n    this._worker = worker;\n    this._worker.onmessage = this._onMessage.bind(this);\n    this._id = Math.ceil(Math.random() * 10000000);\n  }\n\n  terminate() {\n    this._worker.terminate();\n  }\n\n  /**\n   * return true if there is no unresolved jobs\n   * @returns {boolean}\n   */\n  isFree() {\n    return this._messages.size === 0;\n  }\n\n  jobsLength() {\n    return this._messages.size;\n  }\n\n  /**\n   * @param operationName string\n   * @param data any\n   * @param transferable array\n   * @param onEvent function\n   * @returns {Promise}\n   */\n  exec(operationName, data = null, transferable = [], onEvent) {\n    return new Promise((res, rej) => {\n      const messageId = this._messageId++;\n      this._messages.set(messageId, [res, rej, onEvent]);\n      this._worker.postMessage([messageId, data, operationName], transferable || []);\n    });\n  }\n\n  /**\n   *\n   * @param data any\n   * @param transferable array\n   * @param onEvent function\n   * @returns {Promise}\n   */\n  postMessage(data = null, transferable = [], onEvent) {\n    return new Promise((res, rej) => {\n      const messageId = this._messageId++;\n      this._messages.set(messageId, [res, rej, onEvent]);\n      this._worker.postMessage([messageId, data], transferable || []);\n    });\n  }\n\n  emit(eventName, ...args) {\n    this._worker.postMessage({eventName, args});\n  }\n\n  _onMessage(e) {\n    //if we got usual event, just emit it locally\n    if(!Array.isArray(e.data) && e.data.eventName) {\n      return super.emit(e.data.eventName, ...e.data.args);\n    }\n\n    const [type, ...args] = e.data;\n\n    if(type === MESSAGE_EVENT)\n      this._onEvent(...args);\n    else if(type === MESSAGE_RESULT)\n      this._onResult(...args);\n    else\n      throw new Error(`Wrong message type '${type}'`);\n  }\n\n  _onResult(messageId, success, payload) {\n    const [res, rej] = this._messages.get(messageId);\n    this._messages.delete(messageId);\n\n    return success === RESULT_SUCCESS ? res(payload) : rej(payload);\n  }\n\n  _onEvent(messageId, eventName, data) {\n    const [,,onEvent] = this._messages.get(messageId);\n\n    if(onEvent) {\n      onEvent(eventName, data);\n    }\n  }\n\n}\n\nmodule.exports = Worker;\n","class TinyEmitter {\n  constructor() {\n    Object.defineProperty(this, '__listeners', {\n      value: {},\n      enumerable: false,\n      writable: false\n    });\n  }\n\n  emit(eventName, ...args) {\n    if(!this.__listeners[eventName])\n      return this;\n\n    for(const handler of this.__listeners[eventName]) {\n      handler(...args);\n    }\n\n    return this;\n  }\n\n  once(eventName, handler) {\n    const once = (...args) => {\n      this.off(eventName, once);\n      handler(...args);\n    };\n\n    return this.on(eventName, once);\n  }\n\n  on(eventName, handler) {\n    if(!this.__listeners[eventName])\n      this.__listeners[eventName] = [];\n\n    this.__listeners[eventName].push(handler);\n\n    return this;\n  }\n\n  off(eventName, handler) {\n    if(handler)\n      this.__listeners[eventName] = this.__listeners[eventName].filter(h => h !== handler);\n    else\n      this.__listeners[eventName] = [];\n\n    return this;\n  }\n}\n\nmodule.exports = TinyEmitter;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","\"use strict\";\n// Copyright (c) 2022 David Huggins-Daines <dhdaines@gmail.com>\n// Originally based on index.html from pocketsphinx.js, which is:\n// Copyright © 2013-2017 Sylvain Chevalier\n// MIT license, see LICENSE for details\n\nrequire(\"purecss\");\nrequire(\"./index.css\");\n\nconst WebworkerPromise = require(\"webworker-promise\");\n\n// Wait 1s after input to update grammar\nconst INPUT_TIMEOUT = 1000;\n\n// Package these with Webpack\nvar grammars = {Pizza: require(\"./pizza.gram\"),\n\t\tNumbers: require(\"./numbers.gram\"),\n\t\tCities: require(\"./cities.gram\")}\nvar dicts = {Cities: require(\"./cities.dict\")};\n\n// These will be initialized later\nvar outputContainer, context, ssjs, recognizer, media_source, worklet_node;\n// Only when both recorder and recognizer do we have a ready application\nvar isRecorderReady = false;\nvar isRecognizerReady = false;\n// Do not feed data to the recorder if not ready\nvar recording = false;\n\n// To display the hypothesis sent by the recognizer\nfunction updateHyp(hyp) {\n    if (outputContainer)\n\toutputContainer.innerHTML = hyp;\n};\n\n// This updates the UI when the app might get ready\nfunction updateUI() {\n    if (isRecorderReady && isRecognizerReady)\n\tstartBtn.disabled = stopBtn.disabled = false;\n};\n\n// This is just a logging window where we display the status\nfunction updateStatus(newStatus) {\n    document.getElementById('current-status').innerHTML = newStatus;\n};\n\n// A not-so-great recording indicator\nfunction displayRecording(display) {\n    if (display)\n\tdocument.getElementById('recording-indicator').innerHTML = \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\";\n    else\n\tdocument.getElementById('recording-indicator').innerHTML = \"\";\n    recording = display;\n};\n\n// This adds words to the recognizer. When it calls back, we are ready\nasync function feedWords() {\n    for (const name in dicts) {\n\tawait recognizer.exec(\"loadDict\", dicts[name]);\n    }\n};\n\n// When the page is loaded, we spawn a new recognizer worker and\n// call getUserMedia to request access to the microphone\nwindow.onload = async function() {\n    // Wiring JavaScript to the UI\n    const startBtn = document.getElementById('startBtn');\n    const stopBtn = document.getElementById('stopBtn');\n    startBtn.disabled = true;\n    stopBtn.disabled = true;\n\n    // Set up grammar menu and JSGF area\n    var selectTag = document.getElementById('grammars');\n    for (const name in grammars) {\n        var newElt = document.createElement('option');\n        newElt.innerHTML = name;\n        selectTag.appendChild(newElt);\n    }                          \n    var jsgfArea = document.getElementById('jsgf');\n    async function loadGrammar(name) {\n\tlet grammar_url = grammars[name];\n\tlet response = await fetch(grammar_url);\n\tif (response.ok) {\n\t    let jsgf_string = await response.text();\n\t    jsgfArea.value = jsgf_string;\n\t}\n\telse {\n\t    updateStatus(\"Failed to fetch \" + grammar_url + \" :\"\n\t\t\t + response.statusText);\n\t}\n    }\n    // Load the first grammar\n    await loadGrammar(selectTag.options[selectTag.selectedIndex].innerText);\n\n    outputContainer = document.getElementById(\"output\");\n    updateStatus(\"Initializing web audio, waiting for approval to access the microphone\");\n    try {\n\tconst AudioContext = window.AudioContext || window.webkitAudioContext;\n\tcontext = new AudioContext();\n\tawait context.suspend();\n\tconst stream = await navigator.mediaDevices.getUserMedia({audio: true});\n        media_source = context.createMediaStreamSource(stream);\n\tconst workletURL = new URL(\"./soundswallower-processor.js\", import.meta.url);\n\tawait context.audioWorklet.addModule(workletURL);\n\tworklet_node = new AudioWorkletNode(context, 'soundswallower-processor');\n\tmedia_source.connect(worklet_node).connect(context.destination);\n        isRecorderReady = true;\n        updateUI();\n        updateStatus(\"Audio recorder ready\");\n    }\n    catch (e) {\n\tupdateStatus(\"Error initializing Web Audio browser: \" + e.message);\n    }\n    updateStatus(\"Initializing speech recognizer\");\n    try {\n\trecognizer = new WebworkerPromise(\n\t    new Worker(new URL(\"./recognizer.js\", import.meta.url)));\n\tawait recognizer.exec(\"initialize\",\n\t\t\t      {loglevel: \"DEBUG\", samprate: context.sampleRate});\n\tawait feedWords();\n    }\n    catch (e) {\n\tupdateStatus(\"Error initializing speech recognizer: \" + e.message);\n    }\n    async function updateGrammar() {\n\tvar was_recording;\n\tif (recording) {\n\t    was_recording = true;\n\t    await recognizer.exec(\"stop\");\n\t    displayRecording(false);\n\t}\n\ttry {\n\t    await recognizer.exec(\"setJSGF\", jsgfArea.value);\n\t    updateStatus(\"Updated grammar\");\n\t}\n\tcatch (e) {\n\t\tupdateStatus(\"Failed to set grammar: \" + e.message);\n\t}\n\tif (was_recording) {\n\t    try {\n\t\tawait recognizer.exec(\"start\");\n\t    }\n\t    catch (e) {\n\t\tupdateStatus(\"Error starting recognition: \" + e.message);\n\t    }\n\t    displayRecording(true);\n\t}\n    }\n    // Load the current grammar\n    await updateGrammar();\n    updateStatus(\"Speech recognizer ready\");\n\n    // Set up select to update grammar\n    selectTag.addEventListener(\"change\", async function() {\n\tvar name = this.options[this.selectedIndex].innerText;\n\tawait loadGrammar(name);\n\t// Won't actually trigger the input event so update it here\n\tawait updateGrammar();\n    });\n    // Set up handler to reload grammar when modified\n    let timeout = null;\n    jsgfArea.addEventListener(\"input\", () => {\n\tclearTimeout(timeout);\n\ttimeout = setTimeout(updateGrammar, INPUT_TIMEOUT);\n    });\n    worklet_node.port.onmessage = async function(event) {\n\tif (!recording)\n\t    return true;\n\tif (event.data == \"ERROR\") {\n\t    updateStatus(\"AudioWorkletNode got disconnected somehow?!?!?!\");\n\t    worklet_node = new AudioWorkletNode(context, 'soundswallower-processor');\n\t    media_source.connect(worklet_node).connect(context.destination);\n\t    return true;\n\t}\n\ttry {\n\t    await recognizer.exec(\"process\", event.data,\n\t\t\t\t  [event.data.buffer]);\n\t    let hyp = await recognizer.exec(\"getHyp\")\n\t    if (hyp !== undefined)\n\t\tupdateHyp(hyp);\t    \n\t}\n\tcatch (e) {\n\t    updateStatus(\"Error processing data: \" + e.message);\n\t}\n\treturn true;\n    };\n    startBtn.onclick = async function() {\n\tif (recording) {\n\t    await recognizer.exec(\"stop\");\n\t}\n\ttry {\n\t    await recognizer.exec(\"start\");\n\t}\n\tcatch (e) {\n\t    updateStatus(\"Error starting recognition: \" + e.message);\n\t}\n\tawait context.resume();\n\tdisplayRecording(true);\n\treturn true;\n    };\n    stopBtn.onclick = async function() {\n\tawait context.suspend();\n\tif (!recording)\n\t    return;\n\ttry {\n\t    const { hyp, hypseg } = await recognizer.exec(\"stop\");\n\t    if (hyp !== undefined)\n\t\tupdateHyp(hyp);\n\t    displayRecording(false);\n\t}\n\tcatch (e) {\n\t    updateStatus(\"Error stopping recognition: \" + e.message);\n\t}\n\treturn true;\n    };\n    startBtn.disabled = false;\n    stopBtn.disabled = false;\n};\n\n"],"names":[],"sourceRoot":""}