/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../SoundSwallower/jsbuild/model/index.js":
/*!************************************************!*\
  !*** ../SoundSwallower/jsbuild/model/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("module.exports = __dirname;\n\n\n\n//# sourceURL=webpack://soundswallower-demo/../SoundSwallower/jsbuild/model/index.js?");

/***/ }),

/***/ "../SoundSwallower/jsbuild/soundswallower.js":
/*!***************************************************!*\
  !*** ../SoundSwallower/jsbuild/soundswallower.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Module = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;\n  return (\nfunction(Module) {\n  Module = Module || {};\n\nvar Module=typeof Module!=\"undefined\"?Module:{};var readyPromiseResolve,readyPromiseReject;Module[\"ready\"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window==\"object\";var ENVIRONMENT_IS_WORKER=typeof importScripts==\"function\";var ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err(\"exiting due to exception: \"+toLog)}if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=(__webpack_require__(/*! path */ \"?d802\").dirname)(scriptDirectory)+\"/\"}else{scriptDirectory=__dirname+\"/\"}var fs,nodePath;if(true){fs=__webpack_require__(/*! fs */ \"?ea0c\");nodePath=__webpack_require__(/*! path */ \"?d802\")}read_=(filename,binary)=>{filename=nodePath[\"normalize\"](filename);return fs.readFileSync(filename,binary?undefined:\"utf8\")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror)=>{filename=nodePath[\"normalize\"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer)})};if(process[\"argv\"].length>1){thisProgram=process[\"argv\"][1].replace(/\\\\/g,\"/\")}arguments_=process[\"argv\"].slice(2);process[\"on\"](\"uncaughtException\",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process[\"on\"](\"unhandledRejection\",function(reason){throw reason});quit_=(status,toThrow)=>{if(keepRuntimeAlive()){process[\"exitCode\"]=status;throw toThrow}logExceptionOnExit(toThrow);process[\"exit\"](status)};Module[\"inspect\"]=function(){return\"[Emscripten Module object]\"}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf(\"blob:\")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}else{scriptDirectory=\"\"}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime=Module[\"noExitRuntime\"]||true;if(typeof WebAssembly!=\"object\"){abort(\"no native wasm support detected\")}var wasmMemory;var ABORT=false;var EXITSTATUS;var UTF8Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\"\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\"}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module[\"HEAP8\"]=HEAP8=new Int8Array(buf);Module[\"HEAP16\"]=HEAP16=new Int16Array(buf);Module[\"HEAP32\"]=HEAP32=new Int32Array(buf);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(buf);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(buf);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(buf);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(buf);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module[\"INITIAL_MEMORY\"]||33554432;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){{if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}}what=\"Aborted(\"+what+\")\";err(what);ABORT=true;EXITSTATUS=1;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix=\"data:application/octet-stream;base64,\";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith(\"file://\")}var wasmBinaryFile;wasmBinaryFile=\"soundswallower.wasm\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\"function\"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+wasmBinaryFile+\"'\"}return response[\"arrayBuffer\"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={\"a\":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module[\"asm\"]=exports;wasmMemory=Module[\"asm\"][\"v\"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module[\"asm\"][\"D\"];addOnInit(Module[\"asm\"][\"w\"]);removeRunDependency(\"wasm-instantiate\")}addRunDependency(\"wasm-instantiate\");function receiveInstantiationResult(result){receiveInstance(result[\"instance\"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err(\"failed to asynchronously prepare wasm: \"+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==\"function\"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch==\"function\"){return fetch(wasmBinaryFile,{credentials:\"same-origin\"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err(\"wasm streaming compile failed: \"+reason);err(\"falling back to ArrayBuffer instantiation\");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module[\"instantiateWasm\"]){try{var exports=Module[\"instantiateWasm\"](info,receiveInstance);return exports}catch(e){err(\"Module.instantiateWasm callback failed with error: \"+e);readyPromiseReject(e)}}instantiateAsync().catch(readyPromiseReject);return{}}function ExitStatus(status){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+status+\")\";this.status=status}function allocateUTF8OnStack(str){var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8Array(str,HEAP8,ret,size);return ret}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){callbacks.shift()(Module)}}function getCFunc(ident){var func=Module[\"_\"+ident];return func}function ccall(ident,returnType,argTypes,args,opts){var toC={\"string\":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},\"array\":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\"string\"){return UTF8ToString(ret)}if(returnType===\"boolean\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret}function getValue(ptr,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":return HEAP8[ptr>>0];case\"i8\":return HEAP8[ptr>>0];case\"i16\":return HEAP16[ptr>>1];case\"i32\":return HEAP32[ptr>>2];case\"i64\":return HEAP32[ptr>>2];case\"float\":return HEAPF32[ptr>>2];case\"double\":return HEAPF64[ptr>>3];case\"*\":return HEAPU32[ptr>>2];default:abort(\"invalid type for getValue: \"+type)}return null}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function ___assert_fail(condition,filename,line,func){abort(\"Assertion failed: \"+UTF8ToString(condition)+\", at: \"+[filename?UTF8ToString(filename):\"unknown filename\",line,func?UTF8ToString(func):\"unknown function\"])}var SYSCALLS={varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;return 0}function ___syscall_fstat64(fd,buf){}function ___syscall_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;return 0}function ___syscall_newfstatat(dirfd,path,buf,flags){}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs}function ___syscall_stat64(path,buf){}function __emscripten_throw_longjmp(){throw Infinity}function __mmap_js(len,prot,flags,fd,off,allocated,addr){return-52}function __munmap_js(addr,len,prot,flags,fd,offset){}function _abort(){abort(\"\")}function _emscripten_date_now(){return Date.now()}function getHeapMax(){return 2147483648}function _emscripten_get_heap_max(){return getHeapMax()}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var ENV={};function getExecutableName(){return thisProgram||\"./this.program\"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={\"USER\":\"web_user\",\"LOGNAME\":\"web_user\",\"PATH\":\"/\",\"PWD\":\"/\",\"HOME\":\"/home/web_user\",\"LANG\":lang,\"_\":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+\"=\"+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAPU32[penviron_buf_size>>2]=bufSize;return 0}function _proc_exit(code){EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module[\"onExit\"])Module[\"onExit\"](code);ABORT=true}quit_(code,new ExitStatus(code))}function exitJS(status,implicit){EXITSTATUS=status;_proc_exit(status)}var _exit=exitJS;function _fd_close(fd){return 52}function _fd_read(fd,iov,iovcnt,pnum){return 52}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){return 70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0}var asmLibraryArg={\"a\":___assert_fail,\"e\":___syscall_fcntl64,\"u\":___syscall_fstat64,\"h\":___syscall_ioctl,\"s\":___syscall_newfstatat,\"f\":___syscall_openat,\"t\":___syscall_stat64,\"l\":__emscripten_throw_longjmp,\"o\":__mmap_js,\"p\":__munmap_js,\"k\":_abort,\"i\":_emscripten_date_now,\"n\":_emscripten_get_heap_max,\"m\":_emscripten_resize_heap,\"q\":_environ_get,\"r\":_environ_sizes_get,\"b\":_exit,\"c\":_fd_close,\"g\":_fd_read,\"j\":_fd_seek,\"d\":_fd_write};var asm=createWasm();var ___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=function(){return(___wasm_call_ctors=Module[\"___wasm_call_ctors\"]=Module[\"asm\"][\"w\"]).apply(null,arguments)};var _fsg_set_states=Module[\"_fsg_set_states\"]=function(){return(_fsg_set_states=Module[\"_fsg_set_states\"]=Module[\"asm\"][\"x\"]).apply(null,arguments)};var _cmd_ln_hash_iter=Module[\"_cmd_ln_hash_iter\"]=function(){return(_cmd_ln_hash_iter=Module[\"_cmd_ln_hash_iter\"]=Module[\"asm\"][\"y\"]).apply(null,arguments)};var _hash_iter_key=Module[\"_hash_iter_key\"]=function(){return(_hash_iter_key=Module[\"_hash_iter_key\"]=Module[\"asm\"][\"z\"]).apply(null,arguments)};var _set_mdef=Module[\"_set_mdef\"]=function(){return(_set_mdef=Module[\"_set_mdef\"]=Module[\"asm\"][\"A\"]).apply(null,arguments)};var _set_tmat=Module[\"_set_tmat\"]=function(){return(_set_tmat=Module[\"_set_tmat\"]=Module[\"asm\"][\"B\"]).apply(null,arguments)};var _load_gmm=Module[\"_load_gmm\"]=function(){return(_load_gmm=Module[\"_load_gmm\"]=Module[\"asm\"][\"C\"]).apply(null,arguments)};var _config_str=Module[\"_config_str\"]=function(){return(_config_str=Module[\"_config_str\"]=Module[\"asm\"][\"E\"]).apply(null,arguments)};var _config_float=Module[\"_config_float\"]=function(){return(_config_float=Module[\"_config_float\"]=Module[\"asm\"][\"F\"]).apply(null,arguments)};var _config_int=Module[\"_config_int\"]=function(){return(_config_int=Module[\"_config_int\"]=Module[\"asm\"][\"G\"]).apply(null,arguments)};var _config_free=Module[\"_config_free\"]=function(){return(_config_free=Module[\"_config_free\"]=Module[\"asm\"][\"H\"]).apply(null,arguments)};var _acmod_reinit_feat=Module[\"_acmod_reinit_feat\"]=function(){return(_acmod_reinit_feat=Module[\"_acmod_reinit_feat\"]=Module[\"asm\"][\"I\"]).apply(null,arguments)};var _s3file_free=Module[\"_s3file_free\"]=function(){return(_s3file_free=Module[\"_s3file_free\"]=Module[\"asm\"][\"J\"]).apply(null,arguments)};var _bin_mdef_read_s3file=Module[\"_bin_mdef_read_s3file\"]=function(){return(_bin_mdef_read_s3file=Module[\"_bin_mdef_read_s3file\"]=Module[\"asm\"][\"K\"]).apply(null,arguments)};var _malloc=Module[\"_malloc\"]=function(){return(_malloc=Module[\"_malloc\"]=Module[\"asm\"][\"L\"]).apply(null,arguments)};var _free=Module[\"_free\"]=function(){return(_free=Module[\"_free\"]=Module[\"asm\"][\"M\"]).apply(null,arguments)};var _config_parse_json=Module[\"_config_parse_json\"]=function(){return(_config_parse_json=Module[\"_config_parse_json\"]=Module[\"asm\"][\"N\"]).apply(null,arguments)};var _config_set_str=Module[\"_config_set_str\"]=function(){return(_config_set_str=Module[\"_config_set_str\"]=Module[\"asm\"][\"O\"]).apply(null,arguments)};var _config_serialize_json=Module[\"_config_serialize_json\"]=function(){return(_config_serialize_json=Module[\"_config_serialize_json\"]=Module[\"asm\"][\"P\"]).apply(null,arguments)};var _hash_table_iter_next=Module[\"_hash_table_iter_next\"]=function(){return(_hash_table_iter_next=Module[\"_hash_table_iter_next\"]=Module[\"asm\"][\"Q\"]).apply(null,arguments)};var _config_typeof=Module[\"_config_typeof\"]=function(){return(_config_typeof=Module[\"_config_typeof\"]=Module[\"asm\"][\"R\"]).apply(null,arguments)};var _config_set=Module[\"_config_set\"]=function(){return(_config_set=Module[\"_config_set\"]=Module[\"asm\"][\"S\"]).apply(null,arguments)};var _config_set_int=Module[\"_config_set_int\"]=function(){return(_config_set_int=Module[\"_config_set_int\"]=Module[\"asm\"][\"T\"]).apply(null,arguments)};var _config_set_float=Module[\"_config_set_float\"]=function(){return(_config_set_float=Module[\"_config_set_float\"]=Module[\"asm\"][\"U\"]).apply(null,arguments)};var _decoder_init_cleanup=Module[\"_decoder_init_cleanup\"]=function(){return(_decoder_init_cleanup=Module[\"_decoder_init_cleanup\"]=Module[\"asm\"][\"V\"]).apply(null,arguments)};var _decoder_init_fe=Module[\"_decoder_init_fe\"]=function(){return(_decoder_init_fe=Module[\"_decoder_init_fe\"]=Module[\"asm\"][\"W\"]).apply(null,arguments)};var _decoder_init_feat_s3file=Module[\"_decoder_init_feat_s3file\"]=function(){return(_decoder_init_feat_s3file=Module[\"_decoder_init_feat_s3file\"]=Module[\"asm\"][\"X\"]).apply(null,arguments)};var _decoder_init_acmod_pre=Module[\"_decoder_init_acmod_pre\"]=function(){return(_decoder_init_acmod_pre=Module[\"_decoder_init_acmod_pre\"]=Module[\"asm\"][\"Y\"]).apply(null,arguments)};var _decoder_init_acmod_post=Module[\"_decoder_init_acmod_post\"]=function(){return(_decoder_init_acmod_post=Module[\"_decoder_init_acmod_post\"]=Module[\"asm\"][\"Z\"]).apply(null,arguments)};var _decoder_init_dict_s3file=Module[\"_decoder_init_dict_s3file\"]=function(){return(_decoder_init_dict_s3file=Module[\"_decoder_init_dict_s3file\"]=Module[\"asm\"][\"_\"]).apply(null,arguments)};var _decoder_set_fsg=Module[\"_decoder_set_fsg\"]=function(){return(_decoder_set_fsg=Module[\"_decoder_set_fsg\"]=Module[\"asm\"][\"$\"]).apply(null,arguments)};var _fsg_model_free=Module[\"_fsg_model_free\"]=function(){return(_fsg_model_free=Module[\"_fsg_model_free\"]=Module[\"asm\"][\"aa\"]).apply(null,arguments)};var _jsgf_get_rule=Module[\"_jsgf_get_rule\"]=function(){return(_jsgf_get_rule=Module[\"_jsgf_get_rule\"]=Module[\"asm\"][\"ba\"]).apply(null,arguments)};var _jsgf_get_public_rule=Module[\"_jsgf_get_public_rule\"]=function(){return(_jsgf_get_public_rule=Module[\"_jsgf_get_public_rule\"]=Module[\"asm\"][\"ca\"]).apply(null,arguments)};var _jsgf_build_fsg=Module[\"_jsgf_build_fsg\"]=function(){return(_jsgf_build_fsg=Module[\"_jsgf_build_fsg\"]=Module[\"asm\"][\"da\"]).apply(null,arguments)};var _jsgf_grammar_free=Module[\"_jsgf_grammar_free\"]=function(){return(_jsgf_grammar_free=Module[\"_jsgf_grammar_free\"]=Module[\"asm\"][\"ea\"]).apply(null,arguments)};var _decoder_init_grammar_s3file=Module[\"_decoder_init_grammar_s3file\"]=function(){return(_decoder_init_grammar_s3file=Module[\"_decoder_init_grammar_s3file\"]=Module[\"asm\"][\"fa\"]).apply(null,arguments)};var _jsgf_parse_string=Module[\"_jsgf_parse_string\"]=function(){return(_jsgf_parse_string=Module[\"_jsgf_parse_string\"]=Module[\"asm\"][\"ga\"]).apply(null,arguments)};var _decoder_create=Module[\"_decoder_create\"]=function(){return(_decoder_create=Module[\"_decoder_create\"]=Module[\"asm\"][\"ha\"]).apply(null,arguments)};var _decoder_free=Module[\"_decoder_free\"]=function(){return(_decoder_free=Module[\"_decoder_free\"]=Module[\"asm\"][\"ia\"]).apply(null,arguments)};var _decoder_config=Module[\"_decoder_config\"]=function(){return(_decoder_config=Module[\"_decoder_config\"]=Module[\"asm\"][\"ja\"]).apply(null,arguments)};var _decoder_logmath=Module[\"_decoder_logmath\"]=function(){return(_decoder_logmath=Module[\"_decoder_logmath\"]=Module[\"asm\"][\"ka\"]).apply(null,arguments)};var _decoder_set_align_text=Module[\"_decoder_set_align_text\"]=function(){return(_decoder_set_align_text=Module[\"_decoder_set_align_text\"]=Module[\"asm\"][\"la\"]).apply(null,arguments)};var _fsg_model_init=Module[\"_fsg_model_init\"]=function(){return(_fsg_model_init=Module[\"_fsg_model_init\"]=Module[\"asm\"][\"ma\"]).apply(null,arguments)};var _fsg_model_word_add=Module[\"_fsg_model_word_add\"]=function(){return(_fsg_model_word_add=Module[\"_fsg_model_word_add\"]=Module[\"asm\"][\"na\"]).apply(null,arguments)};var _fsg_model_trans_add=Module[\"_fsg_model_trans_add\"]=function(){return(_fsg_model_trans_add=Module[\"_fsg_model_trans_add\"]=Module[\"asm\"][\"oa\"]).apply(null,arguments)};var _decoder_seg_iter=Module[\"_decoder_seg_iter\"]=function(){return(_decoder_seg_iter=Module[\"_decoder_seg_iter\"]=Module[\"asm\"][\"pa\"]).apply(null,arguments)};var _seg_iter_next=Module[\"_seg_iter_next\"]=function(){return(_seg_iter_next=Module[\"_seg_iter_next\"]=Module[\"asm\"][\"qa\"]).apply(null,arguments)};var _decoder_add_word=Module[\"_decoder_add_word\"]=function(){return(_decoder_add_word=Module[\"_decoder_add_word\"]=Module[\"asm\"][\"ra\"]).apply(null,arguments)};var _decoder_lookup_word=Module[\"_decoder_lookup_word\"]=function(){return(_decoder_lookup_word=Module[\"_decoder_lookup_word\"]=Module[\"asm\"][\"sa\"]).apply(null,arguments)};var _decoder_start_utt=Module[\"_decoder_start_utt\"]=function(){return(_decoder_start_utt=Module[\"_decoder_start_utt\"]=Module[\"asm\"][\"ta\"]).apply(null,arguments)};var _decoder_process_float32=Module[\"_decoder_process_float32\"]=function(){return(_decoder_process_float32=Module[\"_decoder_process_float32\"]=Module[\"asm\"][\"ua\"]).apply(null,arguments)};var _decoder_end_utt=Module[\"_decoder_end_utt\"]=function(){return(_decoder_end_utt=Module[\"_decoder_end_utt\"]=Module[\"asm\"][\"va\"]).apply(null,arguments)};var _decoder_hyp=Module[\"_decoder_hyp\"]=function(){return(_decoder_hyp=Module[\"_decoder_hyp\"]=Module[\"asm\"][\"wa\"]).apply(null,arguments)};var _seg_iter_word=Module[\"_seg_iter_word\"]=function(){return(_seg_iter_word=Module[\"_seg_iter_word\"]=Module[\"asm\"][\"xa\"]).apply(null,arguments)};var _seg_iter_frames=Module[\"_seg_iter_frames\"]=function(){return(_seg_iter_frames=Module[\"_seg_iter_frames\"]=Module[\"asm\"][\"ya\"]).apply(null,arguments)};var _decoder_result_json=Module[\"_decoder_result_json\"]=function(){return(_decoder_result_json=Module[\"_decoder_result_json\"]=Module[\"asm\"][\"za\"]).apply(null,arguments)};var _fsg_model_null_trans_add=Module[\"_fsg_model_null_trans_add\"]=function(){return(_fsg_model_null_trans_add=Module[\"_fsg_model_null_trans_add\"]=Module[\"asm\"][\"Aa\"]).apply(null,arguments)};var _logmath_log=Module[\"_logmath_log\"]=function(){return(_logmath_log=Module[\"_logmath_log\"]=Module[\"asm\"][\"Ba\"]).apply(null,arguments)};var _s3file_init=Module[\"_s3file_init\"]=function(){return(_s3file_init=Module[\"_s3file_init\"]=Module[\"asm\"][\"Ca\"]).apply(null,arguments)};var _tmat_init_s3file=Module[\"_tmat_init_s3file\"]=function(){return(_tmat_init_s3file=Module[\"_tmat_init_s3file\"]=Module[\"asm\"][\"Da\"]).apply(null,arguments)};var stackSave=Module[\"stackSave\"]=function(){return(stackSave=Module[\"stackSave\"]=Module[\"asm\"][\"Ea\"]).apply(null,arguments)};var stackRestore=Module[\"stackRestore\"]=function(){return(stackRestore=Module[\"stackRestore\"]=Module[\"asm\"][\"Fa\"]).apply(null,arguments)};var stackAlloc=Module[\"stackAlloc\"]=function(){return(stackAlloc=Module[\"stackAlloc\"]=Module[\"asm\"][\"Ga\"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(function(){setTimeout(function(){Module[\"setStatus\"](\"\")},1);doRun()},1)}else{doRun()}}if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}run();const ARG_INTEGER=1<<1;const ARG_FLOATING=1<<2;const ARG_STRING=1<<3;const ARG_BOOLEAN=1<<4;const DEFAULT_MODEL=\"en-us\";if(typeof Module.defaultModel===\"undefined\"){Module.defaultModel=DEFAULT_MODEL}if(typeof Module.modelBase===\"undefined\"){if(ENVIRONMENT_IS_WEB){Module.modelBase=\"model/\"}else{Module.modelBase=__webpack_require__(/*! ./model/index.js */ \"../SoundSwallower/jsbuild/model/index.js\")}}class Decoder{constructor(config){this.initialized=false;if(typeof config===\"undefined\")config={};if(Module.defaultModel!==null&&config.hmm===undefined)config.hmm=Module.get_model_path(Module.defaultModel);const cjson=allocateUTF8OnStack(JSON.stringify(config));const cconfig=Module._config_parse_json(0,cjson);this.cdecoder=Module._decoder_create(cconfig);if(this.cdecoder==0)throw new Error(\"Failed to construct Decoder\")}delete(){if(this.cdecoder!=0)Module._decoder_free(this.cdecoder);this.cdecoder=0}get_config_json(){const cconfig=Module._decoder_config(this.cdecoder);const cjson=Module._config_serialize_json(cconfig);return UTF8ToString(cjson)}set_config(key,val){const ckey=allocateUTF8OnStack(key);const cconfig=Module._decoder_config(this.cdecoder);const type=Module._config_typeof(cconfig,ckey);if(type==0){throw new ReferenceError(\"Unknown cmd_ln parameter \"+key)}if(type&ARG_STRING){const cval=allocateUTF8OnStack(val);Module._config_set_str(cconfig,ckey,cval)}else if(type&ARG_FLOATING){Module._config_set_float(cconfig,ckey,val)}else if(type&(ARG_INTEGER|ARG_BOOLEAN)){Module._config_set_int(cconfig,ckey,val)}else{return false}return true}unset_config(key){const ckey=allocateUTF8OnStack(key);const cconfig=Module._decoder_config(this.cdecoder);const type=Module._config_typeof(cconfig,ckey);if(type==0){throw new ReferenceError(\"Unknown cmd_ln parameter \"+key)}Module._config_set(cconfig,ckey,0,type)}get_config(key){const ckey=allocateUTF8OnStack(key);const cconfig=Module._decoder_config(this.cdecoder);const type=Module._config_typeof(cconfig,ckey);if(type==0){throw new ReferenceError(\"Unknown cmd_ln parameter \"+key)}if(type&ARG_STRING){const val=Module._config_str(cconfig,ckey);if(val==0)return null;return UTF8ToString(val)}else if(type&ARG_FLOATING){return Module._config_float(cconfig,ckey)}else if(type&ARG_INTEGER){return Module._config_int(cconfig,ckey)}else if(type&ARG_BOOLEAN){return Boolean(Module._config_int(cconfig,ckey))}else{throw new TypeError(\"Unsupported type \"+type+\" for parameter\"+key)}}has_config(key){const ckey=allocateUTF8OnStack(key);const cconfig=Module._decoder_config(this.cdecoder);return Module._config_typeof(cconfig,ckey)!=0}async initialize(){if(this.cdecoder==0)throw new Error(\"Decoder was somehow not constructed (ps==0)\");await this.init_featparams();await this.init_cleanup();await this.init_fe();await this.init_feat();this.cacmod=await this.init_acmod();await this.load_acmod_files();await this.init_dict();await this.init_grammar();this.initialized=true}async init_featparams(){const fpdata=await load_json(this.get_config(\"featparams\"));for(const key in fpdata){if(this.has_config(key))this.set_config(key,fpdata[key])}return fpdata}async init_cleanup(){let rv=Module._decoder_init_cleanup(this.cdecoder);if(rv<0)throw new Error(\"Failed to clean up decoder internals\")}async init_fe(){const rv=Module._decoder_init_fe(this.cdecoder);if(rv==0)throw new Error(\"Failed to initialize frontend\");return rv}async init_feat(){let rv;try{const lda=await load_to_s3file(this.get_config(\"lda\"));rv=Module._decoder_init_feat_s3file(this.cdecoder,lda)}catch(e){rv=Module._decoder_init_feat_s3file(this.cdecoder,0)}if(rv==0)throw new Error(\"Failed to initialize feature module\");return rv}async init_acmod(){const rv=Module._decoder_init_acmod_pre(this.cdecoder);if(rv==0)throw new Error(\"Failed to initialize acoustic model\");return rv}async load_acmod_files(){await this.load_mdef();await this.load_tmat(this.get_config(\"tmat\"));const means=this.get_config(\"mean\");const variances=this.get_config(\"var\");const sendump=this.get_config(\"sendump\");const mixw=this.get_config(\"mixw\");await this.load_gmm(means,variances,sendump,mixw);const rv=Module._decoder_init_acmod_post(this.cdecoder);if(rv<0)throw new Error(\"Failed to initialize acoustic scoring\")}async load_mdef(){const s3f=await load_to_s3file(this.get_config(\"mdef\"));if(s3f==0)throw new Error(\"Failed to read mdef from \"+this.get_config(\"mdef\"));const mdef=Module._bin_mdef_read_s3file(s3f,this.get_config(\"cionly\"));Module._s3file_free(s3f);if(mdef==0)throw new Error(\"Failed to read mdef from \"+this.get_config(\"mdef\"));Module._set_mdef(this.cdecoder,mdef);return mdef}async load_tmat(tmat_path){const s3f=await load_to_s3file(tmat_path);const logmath=Module._decoder_logmath(this.cdecoder);const tpfloor=this.get_config(\"tmatfloor\");const tmat=Module._tmat_init_s3file(s3f,logmath,tpfloor);Module._s3file_free(s3f);if(tmat==0)throw new Error(\"Failed to read tmat\");Module._set_tmat(this.cdecoder,tmat);return tmat}async load_gmm(means_path,variances_path,sendump_path,mixw_path){const means=await load_to_s3file(means_path);const variances=await load_to_s3file(variances_path);var sendump,mixw;try{sendump=await load_to_s3file(sendump_path);mixw=0}catch(e){sendump=0;mixw=await load_to_s3file(mixw_path)}if(Module._load_gmm(this.cdecoder,means,variances,mixw,sendump)<0)throw new Error(\"Failed to load GMM parameters\")}async init_dict(){let dict;try{dict=await load_to_s3file(this.get_config(\"dict\"))}catch(e){dict=0}let fdict;try{fdict=await load_to_s3file(this.get_config(\"fdict\"))}catch(e){fdict=0}const rv=Module._decoder_init_dict_s3file(this.cdecoder,dict,fdict);if(rv==0)throw new Error(\"Failed to initialize dictionaries\")}async init_grammar(){let fsg=0,jsgf=0;const jsgf_path=this.get_config(\"jsgf\");if(jsgf_path!=null)jsgf=await load_to_s3file(jsgf_path);const fsg_path=this.get_config(\"fsg\");if(fsg_path!=null)fsg=await load_to_s3file(fsg_path);if(fsg||jsgf){const rv=Module._decoder_init_grammar_s3file(this.cdecoder,fsg,jsgf);if(rv<0)throw new Error(\"Failed to initialize grammar\")}}assert_initialized(){if(!this.initialized)throw new Error(\"Decoder not yet initialized\")}async reinitialize_audio(){this.assert_initialized();const fe=await this.init_fe();const fcb=await this.init_feat();if(Module._acmod_reinit_feat(this.cacmod,fe,fcb)<0){throw new Error(\"Failed to reinitialize audio parameters\")}}async start(){this.assert_initialized();if(Module._decoder_start_utt(this.cdecoder)<0){throw new Error(\"Failed to start utterance processing\")}}async stop(){this.assert_initialized();if(Module._decoder_end_utt(this.cdecoder)<0){throw new Error(\"Failed to stop utterance processing\")}}async process(pcm,no_search=false,full_utt=false){this.assert_initialized();const pcm_bytes=pcm.length*pcm.BYTES_PER_ELEMENT;const pcm_addr=Module._malloc(pcm_bytes);const pcm_u8=new Uint8Array(pcm.buffer);writeArrayToMemory(pcm_u8,pcm_addr);const rv=Module._decoder_process_float32(this.cdecoder,pcm_addr,pcm_bytes/4,no_search,full_utt);Module._free(pcm_addr);if(rv<0){throw new Error(\"Utterance processing failed\")}return rv}get_hyp(){this.assert_initialized();return UTF8ToString(Module._decoder_hyp(this.cdecoder,0))}get_hypseg(){this.assert_initialized();let itor=Module._decoder_seg_iter(this.cdecoder);const config=Module._decoder_config(this.cdecoder);const frate=Module._config_int(config,allocateUTF8OnStack(\"frate\"));const seg=[];while(itor!=0){const frames=stackAlloc(8);Module._seg_iter_frames(itor,frames,frames+4);const start_frame=getValue(frames,\"i32\");const end_frame=getValue(frames+4,\"i32\");const seg_item={word:UTF8ToString(Module._seg_iter_word(itor)),start:start_frame/frate,end:end_frame/frate};seg.push(seg_item);itor=Module._seg_iter_next(itor)}return seg}async get_alignment_json(start=0,align_level=1){this.assert_initialized();const cjson=Module._decoder_result_json(this.cdecoder,start,align_level);return UTF8ToString(cjson)}lookup_word(word){this.assert_initialized();const cword=allocateUTF8OnStack(word);const cpron=Module._decoder_lookup_word(this.cdecoder,cword);if(cpron==0)return null;return UTF8ToString(cpron)}async add_word(word,pron,update=true){this.assert_initialized();const cword=allocateUTF8OnStack(word);const cpron=allocateUTF8OnStack(pron);const wid=Module._decoder_add_word(this.cdecoder,cword,cpron,update);if(wid<0)throw new Error(\"Failed to add word \"+word+\" with pronunciation \"+pron+\" to the dictionary.\");return wid}async set_fsg(name,start_state,final_state,transitions){this.assert_initialized();const logmath=Module._decoder_logmath(this.cdecoder);const config=Module._decoder_config(this.cdecoder);const lw=Module._config_float(config,allocateUTF8OnStack(\"lw\"));let n_state=0;for(const t of transitions){n_state=Math.max(n_state,t.from,t.to)}n_state++;const fsg=ccall(\"fsg_model_init\",\"number\",[\"string\",\"number\",\"number\",\"number\"],[name,logmath,lw,n_state]);Module._fsg_set_states(fsg,start_state,final_state);for(const t of transitions){let logprob=0;if(\"prob\"in t){logprob=Module._logmath_log(logmath,t.prob)}if(\"word\"in t){const wid=ccall(\"fsg_model_word_add\",\"number\",[\"number\",\"string\"],[fsg,t.word]);if(wid==-1){Module._fsg_model_free(fsg);throw new Error(`Failed to add word ${t.word} to FSG`)}Module._fsg_model_trans_add(fsg,t.from,t.to,logprob,wid)}else{Module._fsg_model_null_trans_add(fsg,t.from,t.to,logprob)}}if(Module._decoder_set_fsg(this.cdecoder,fsg)!=0)throw new Error(\"Failed to set FSG in decoder\")}async set_jsgf(jsgf_string,toprule=null){this.assert_initialized();const logmath=Module._decoder_logmath(this.cdecoder);const config=Module._decoder_config(this.cdecoder);const lw=Module._config_float(config,allocateUTF8OnStack(\"lw\"));const cjsgf=allocateUTF8OnStack(jsgf_string);const jsgf=Module._jsgf_parse_string(cjsgf,0);if(jsgf==0)throw new Error(\"Failed to parse JSGF\");let rule;if(toprule!==null){const crule=allocateUTF8OnStack(toprule);rule=Module._jsgf_get_rule(jsgf,crule);if(rule==0)throw new Error(\"Failed to find top rule \"+toprule)}else{rule=Module._jsgf_get_public_rule(jsgf);if(rule==0)throw new Error(\"No public rules found in JSGF\")}const fsg=Module._jsgf_build_fsg(jsgf,rule,logmath,lw);Module._jsgf_grammar_free(jsgf);if(Module._decoder_set_fsg(this.cdecoder,fsg)<0)throw new Error(\"Failed to set FSG in decoder\")}async set_align_text(text){this.assert_initialized();const ctext=allocateUTF8OnStack(text);if(Module._decoder_set_align_text(this.cdecoder,ctext)<0)throw new Error(\"Failed to set alignment text\")}}async function load_json(path){if(ENVIRONMENT_IS_WEB){const response=await fetch(path);if(response.ok)return response.json();else throw new Error(\"Failed to fetch \"+path+\" :\"+response.statusText)}else{const fs=__webpack_require__(/*! fs/promises */ \"?63ba\");const data=await fs.readFile(path,{encoding:\"utf8\"});return JSON.parse(data)}}async function load_to_s3file(path){let blob_u8;if(ENVIRONMENT_IS_WEB){const response=await fetch(path);if(response.ok){const blob=await response.blob();const blob_buf=await blob.arrayBuffer();blob_u8=new Uint8Array(blob_buf)}else throw new Error(\"Failed to fetch \"+path+\" :\"+response.statusText)}else{const fs=__webpack_require__(/*! fs/promises */ \"?63ba\");const blob=await fs.readFile(path);blob_u8=new Uint8Array(blob.buffer)}const blob_len=blob_u8.length+1;const blob_addr=Module._malloc(blob_len);if(blob_addr==0)throw new Error(\"Failed to allocate \"+blob_len+\" bytes for \"+path);writeArrayToMemory(blob_u8,blob_addr);HEAP8[blob_addr+blob_len]=0;return Module._s3file_init(blob_addr,blob_len-1)}function get_model_path(subpath){if(ENVIRONMENT_IS_WEB){return Module.modelBase+subpath}else{const path=__webpack_require__(/*! path */ \"?d802\");return path.join(Module.modelBase,subpath)}}Module.get_model_path=get_model_path;Module.Decoder=Decoder;\n\n\n  return Module.ready\n}\n);\n})();\nif (true)\n  module.exports = Module;\nelse {}\n\n\n//# sourceURL=webpack://soundswallower-demo/../SoundSwallower/jsbuild/soundswallower.js?");

/***/ }),

/***/ "./node_modules/purecss/build/pure-min.css":
/*!*************************************************!*\
  !*** ./node_modules/purecss/build/pure-min.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://soundswallower-demo/./node_modules/purecss/build/pure-min.css?");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://soundswallower-demo/./src/index.css?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (c) 2022 David Huggins-Daines <dhdaines@gmail.com>\n// Originally based on index.html from pocketsphinx.js, which is:\n// Copyright Â© 2013-2017 Sylvain Chevalier\n// MIT license, see LICENSE for details\n\n__webpack_require__(/*! purecss */ \"./node_modules/purecss/build/pure-min.css\");\n__webpack_require__(/*! ./index.css */ \"./src/index.css\");\n\nconst VAD = __webpack_require__(/*! ./vad.js */ \"./src/vad.js\");\n\n// Wait 1s after input to update grammar\nconst INPUT_TIMEOUT = 1000;\n\n// Package these with Webpack\nvar grammars = {Pizza: __webpack_require__(/*! ./pizza.gram */ \"./src/pizza.gram\"),\n                Numbers: __webpack_require__(/*! ./numbers.gram */ \"./src/numbers.gram\"),\n                Cities: __webpack_require__(/*! ./cities.gram */ \"./src/cities.gram\")}\nvar dicts = {Cities: __webpack_require__(/*! ./cities.dict */ \"./src/cities.dict\")};\n\n// These will be initialized later\nvar context, ssjs, vader, decoder, media_source, worklet_node;\n\n// Has ASR been started? FIXME: Should go in ssjs.Decoder\nvar decoding = false;\n\n// To display the hypothesis sent by the recognizer\nfunction updateHyp(hyp) {\n    document.getElementById(\"output\").innerHTML = hyp;\n}\n\n// This is just a logging window where we display the status\nfunction updateStatus(newStatus) {\n    document.getElementById('current-status').innerHTML = newStatus;\n}\n\n// A not-so-great recording indicator\nfunction displayRecording(display) {\n    if (display) {\n        document.getElementById('recording-indicator').innerHTML = \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\";\n        document.getElementById('stopBtn').disabled = false;\n        updateHyp(\"\");\n    }\n    else {\n        document.getElementById('recording-indicator').innerHTML = \"\";\n        document.getElementById('stopBtn').disabled = true;\n    }\n}\n\n// This adds words to the recognizer. When it calls back, we are ready\nasync function feedWords() {\n    for (const name in dicts) { // it is not iterable... wow\n        let response = await fetch(dicts[name]);\n        if (response.ok) {\n            let dict_string = await response.text();\n            let re = /^(\\S+)\\s+(.*)$/mg;\n            for (const m of dict_string.trim().matchAll(re)) {\n                // Fancy way to tell if this is the last line\n                let end = m.index + m[0].length;\n                let rv = await decoder.add_word(m[1], m[2],\n                                                (end == dict_string.length));\n                if (rv == -1)\n                    throw new Error(\"Failed to add word \"\n                                    + m[1] + \" with pronunciation \" + m[2]);\n            }\n        }\n        else\n            throw new Error(\"Failed to fetch \" + dicts[name] + \" :\"\n                            + response.statusText);\n    }\n}\n\nasync function updateGrammar() {\n    if (decoding) {\n        await decoder.stop();\n        decoding = false;\n    }\n    displayRecording(false);\n    try {\n        const jsgfArea = document.getElementById('jsgf');\n        await decoder.set_jsgf(jsgfArea.value);\n        updateStatus(\"Updated grammar\");\n    }\n    catch (e) {\n        updateStatus(\"Failed to set grammar: \" + e.message);\n        throw e;\n    }\n}\n\nasync function loadGrammar(name) {\n    let grammar_url = grammars[name];\n    let response = await fetch(grammar_url);\n    if (response.ok) {\n        let jsgf_string = await response.text();\n        const jsgfArea = document.getElementById('jsgf');\n        jsgfArea.value = jsgf_string;\n    }\n    else {\n        updateStatus(\"Failed to fetch \" + grammar_url + \" :\"\n                     + response.statusText);\n    }\n}\n\nwindow.onload = async function() {\n    // Load the WASM module\n    ssjs = await __webpack_require__(/*! soundswallower */ \"../SoundSwallower/jsbuild/soundswallower.js\")();\n\n    // Wiring JavaScript to the UI\n    const startBtn = document.getElementById('startBtn');\n    const stopBtn = document.getElementById('stopBtn');\n    const jsgfArea = document.getElementById('jsgf');\n    startBtn.disabled = true;\n    stopBtn.disabled = true;\n\n    // Set up grammar menu and JSGF area\n    var selectTag = document.getElementById('grammars');\n    for (const name in grammars) {\n        var newElt = document.createElement('option');\n        newElt.innerHTML = name;\n        selectTag.appendChild(newElt);\n    }                          \n    // Load the first grammar\n    await loadGrammar(selectTag.options[selectTag.selectedIndex].innerText);\n    // Set up handler to reload grammar when modified\n    let timeout = null;\n    jsgfArea.addEventListener(\"input\", () => {\n        clearTimeout(timeout);\n        timeout = setTimeout(updateGrammar, INPUT_TIMEOUT);\n    });\n    // Set up select to update grammar\n    selectTag.addEventListener(\"change\", async function() {\n        var name = this.options[this.selectedIndex].innerText;\n        await loadGrammar(name);\n        // Won't actually trigger the input event so update it here\n        await updateGrammar();\n    });\n\n    updateStatus(\"Initializing web audio, waiting for approval to access the microphone\");\n    try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        context = new AudioContext();\n        await context.suspend();\n        const stream = await navigator.mediaDevices.getUserMedia({audio: true});\n        media_source = context.createMediaStreamSource(stream);\n        const workletURL = new URL(/* asset import */ __webpack_require__(/*! ./processors.js */ \"./src/processors.js\"), __webpack_require__.b);\n        await context.audioWorklet.addModule(workletURL);\n        worklet_node = new AudioWorkletNode(context, 'getaudio-processor', {\n            /* Verbose Web Audio junk... */\n            processorOptions: {\n                bufferSize: 2048,\n                channel: 0,\n            }\n        });\n        media_source.connect(worklet_node);\n        updateStatus(\"Audio recorder ready\");\n    }\n    catch (e) {\n        updateStatus(\"Error initializing Web Audio browser: \" + e.message);\n        return false;\n    }\n\n    updateStatus(\"Initializing speech recognizer\");\n    try {\n        decoder = new ssjs.Decoder({samprate: context.sampleRate});\n        await decoder.initialize();\n        await feedWords();\n        await updateGrammar();\n    }\n    catch (e) {\n        updateStatus(\"Error initializing speech recognizer: \" + e.message);\n        return false;\n    }\n    updateStatus(\"Speech recognizer ready\");\n\n    // Handle VAD and speech input\n    vader = new VAD({\n        context: context, source: worklet_node,\n        voice_start: async () => {\n            if (decoding)\n                return;\n            try {\n                await decoder.start();\n                decoding = true;\n            }\n            catch (e) {\n                updateStatus(\"Error starting recognition: \" + e.message);\n                throw e;\n            }\n        },});\n    worklet_node.port.onmessage = async function(event) {\n        if (!decoding)\n            return true;\n        if (event.data == \"ERROR\") {\n            updateStatus(\"AudioWorkletNode got disconnected somehow?!?!?!\");\n            worklet_node = new AudioWorkletNode(context, 'getaudio-processor');\n            media_source.connect(worklet_node).connect(context.destination);\n            return true;\n        }\n        try {\n            await decoder.process(event.data);\n            let hyp = await decoder.get_hyp();\n            if (hyp !== undefined)\n                updateHyp(hyp);     \n        }\n        catch (e) {\n            updateStatus(\"Error processing data: \" + e.message);\n            throw e;\n        }\n        return true;\n    };\n    startBtn.onclick = async function() {\n        if (decoding) {\n            await decoder.stop();\n            decoding = false;\n            vader.voice_start();\n        }\n        await context.resume();\n        displayRecording(true);\n        return true;\n    };\n    stopBtn.onclick = async function() {\n        await context.suspend();\n        if (!decoding)\n            return;\n        try {\n            await decoder.stop();\n            const hyp = decoder.get_hyp();\n            if (hyp !== undefined)\n                updateHyp(hyp);\n            decoding = false;\n        }\n        catch (e) {\n            updateStatus(\"Error stopping recognition: \" + e.message);\n            throw e;\n        }\n        displayRecording(false);\n        return true;\n    };\n    startBtn.disabled = false;\n}\n\n\n//# sourceURL=webpack://soundswallower-demo/./src/index.js?");

/***/ }),

/***/ "./src/vad.js":
/*!********************!*\
  !*** ./src/vad.js ***!
  \********************/
/***/ ((module) => {

eval("/**\n * Voice activity detector.\n *\n * Based on vad.js (c) 2015 Kelly Davis, 3-clause BSD, see LICENSE for more information.\n */\n\nclass VAD {\n    constructor(options) {\n        // Default options\n        this.options = {\n            fftSize: 512,\n            bufferLen: 512, \n            voice_stop: function() {},\n            voice_start: function() {},\n            smoothingTimeConstant: 0.99, \n            energy_offset: 1e-8, // The initial offset.\n            energy_threshold_ratio_pos: 2, // Signal must be twice the offset\n            energy_threshold_ratio_neg: 0.5, // Signal must be half the offset\n            energy_integration: 1, // Size of integration change compared to the signal per second.\n            filter: [\n                {f: 200, v:0}, // 0 -> 200 is 0\n                {f: 2000, v:1} // 200 -> 2k is 1\n            ],\n            source: null,\n            context: null,\n        };\n\n        // User options\n        for(var option in options) {\n            if(options.hasOwnProperty(option)) {\n                this.options[option] = options[option];\n            }\n        }\n\n        // Require source\n        if(!this.options.source)\n            throw new Error(\"The options must specify a MediaStreamAudioSourceNode.\");\n\n        // Set this.options.context\n        this.options.context = this.options.source.context;\n\n        // Calculate time relationships\n        this.hertzPerBin = this.options.context.sampleRate / this.options.fftSize;\n        this.iterationFrequency = this.options.context.sampleRate / this.options.bufferLen;\n        this.iterationPeriod = 1 / this.iterationFrequency;\n\n        var DEBUG = true;\n        if(DEBUG) console.log(\n            'Vad' +\n                ' | sampleRate: ' + this.options.context.sampleRate +\n                ' | hertzPerBin: ' + this.hertzPerBin +\n                ' | iterationFrequency: ' + this.iterationFrequency +\n                ' | iterationPeriod: ' + this.iterationPeriod\n        );\n\n        this.setFilter(this.options.filter);\n\n        this.ready = {};\n        this.vadState = false; // True when Voice Activity Detected\n\n        // Energy detector props\n        this.energy_offset = this.options.energy_offset;\n        this.energy_threshold_pos = this.energy_offset * this.options.energy_threshold_ratio_pos;\n        this.energy_threshold_neg = this.energy_offset * this.options.energy_threshold_ratio_neg;\n\n        this.voiceTrend = 0;\n        this.voiceTrendMax = 10;\n        this.voiceTrendMin = -10;\n        this.voiceTrendStart = 5;\n        this.voiceTrendEnd = -5;\n\n        // Create analyser \n        this.analyser = this.options.context.createAnalyser();\n        this.analyser.smoothingTimeConstant = this.options.smoothingTimeConstant; // 0.99;\n        this.analyser.fftSize = this.options.fftSize;\n\n        this.floatFrequencyData = new Float32Array(this.analyser.frequencyBinCount);\n\n        // Setup local storage of the Linear FFT data\n        this.floatFrequencyDataLinear = new Float32Array(this.floatFrequencyData.length);\n\n        // Connect this.analyser\n        this.options.source.connect(this.analyser); \n\n        // Create ScriptProcessorNode\n        this.scriptProcessorNode = this.options.context.createScriptProcessor(this.options.bufferLen, 1, 1);\n\n        // Connect scriptProcessorNode (Theretically, not required)\n        this.scriptProcessorNode.connect(this.options.context.destination);\n\n        // Create callback to update/analyze floatFrequencyData\n        var self = this;\n        this.scriptProcessorNode.onaudioprocess = function(event) {\n            self.analyser.getFloatFrequencyData(self.floatFrequencyData);\n            self.update();\n            self.monitor();\n        };\n\n        // Connect scriptProcessorNode\n        this.options.source.connect(this.scriptProcessorNode);\n\n        // log stuff\n        this.logging = false;\n        this.log_i = 0;\n        this.log_limit = 100;\n    }\n\n    setFilter(shape) {\n        this.filter = [];\n        for(var i = 0, iLen = this.options.fftSize / 2; i < iLen; i++) {\n            this.filter[i] = 0;\n            for(var j = 0, jLen = shape.length; j < jLen; j++) {\n                if(i * this.hertzPerBin < shape[j].f) {\n                    this.filter[i] = shape[j].v;\n                    break; // Exit j loop\n                }\n            }\n        }\n    }\n\n    triggerLog(limit) {\n        this.logging = true;\n        this.log_i = 0;\n        this.log_limit = typeof limit === 'number' ? limit : this.log_limit;\n    }\n\n    log(msg) {\n        if(this.logging && this.log_i < this.log_limit) {\n            this.log_i++;\n            console.log(msg);\n        } else {\n            this.logging = false;\n        }\n    }\n\n    update() {\n        // Update the local version of the Linear FFT\n        var fft = this.floatFrequencyData;\n        for(var i = 0, iLen = fft.length; i < iLen; i++) {\n            this.floatFrequencyDataLinear[i] = Math.pow(10, fft[i] / 10);\n        }\n        this.ready = {};\n    }\n\n    getEnergy() {\n        if(this.ready.energy) {\n            return this.energy;\n        }\n\n        var energy = 0;\n        var fft = this.floatFrequencyDataLinear;\n\n        for(var i = 0, iLen = fft.length; i < iLen; i++) {\n            energy += this.filter[i] * fft[i] * fft[i];\n        }\n\n        this.energy = energy;\n        this.ready.energy = true;\n\n        return energy;\n    }\n\n    monitor() {\n        var energy = this.getEnergy();\n        var signal = energy - this.energy_offset;\n\n        if(signal > this.energy_threshold_pos) {\n            this.voiceTrend = (this.voiceTrend + 1 > this.voiceTrendMax) ? this.voiceTrendMax : this.voiceTrend + 1;\n        } else if(signal < -this.energy_threshold_neg) {\n            this.voiceTrend = (this.voiceTrend - 1 < this.voiceTrendMin) ? this.voiceTrendMin : this.voiceTrend - 1;\n        } else {\n            // voiceTrend gets smaller\n            if(this.voiceTrend > 0) {\n                this.voiceTrend--;\n            } else if(this.voiceTrend < 0) {\n                this.voiceTrend++;\n            }\n        }\n\n        var start = false, end = false;\n        if(this.voiceTrend > this.voiceTrendStart) {\n            // Start of speech detected\n            start = true;\n        } else if(this.voiceTrend < this.voiceTrendEnd) {\n            // End of speech detected\n            end = true;\n        }\n\n        // Integration brings in the real-time aspect through the relationship with the frequency this functions is called.\n        var integration = signal * this.iterationPeriod * this.options.energy_integration;\n\n        // Idea?: The integration is affected by the voiceTrend magnitude? - Not sure. Not doing atm.\n\n        // The !end limits the offset delta boost till after the end is detected.\n        if(integration > 0 || !end) {\n            this.energy_offset += integration;\n        } else {\n            this.energy_offset += integration * 10;\n        }\n        this.energy_offset = this.energy_offset < 0 ? 0 : this.energy_offset;\n        this.energy_threshold_pos = this.energy_offset * this.options.energy_threshold_ratio_pos;\n        this.energy_threshold_neg = this.energy_offset * this.options.energy_threshold_ratio_neg;\n\n        // Broadcast the messages\n        if(start && !this.vadState) {\n            this.vadState = true;\n            this.options.voice_start();\n        }\n        if(end && this.vadState) {\n            this.vadState = false;\n            this.options.voice_stop();\n        }\n\n        this.log(\n            'e: ' + energy +\n                ' | e_of: ' + this.energy_offset +\n                ' | e+_th: ' + this.energy_threshold_pos +\n                ' | e-_th: ' + this.energy_threshold_neg +\n                ' | signal: ' + signal +\n                ' | int: ' + integration +\n                ' | voiceTrend: ' + this.voiceTrend +\n                ' | start: ' + start +\n                ' | end: ' + end\n        );\n\n        return signal;\n    }\n}\nmodule.exports = VAD;\n\n\n//# sourceURL=webpack://soundswallower-demo/./src/vad.js?");

/***/ }),

/***/ "./src/cities.dict":
/*!*************************!*\
  !*** ./src/cities.dict ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"model/cities.dict\";\n\n//# sourceURL=webpack://soundswallower-demo/./src/cities.dict?");

/***/ }),

/***/ "./src/cities.gram":
/*!*************************!*\
  !*** ./src/cities.gram ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"model/cities.gram\";\n\n//# sourceURL=webpack://soundswallower-demo/./src/cities.gram?");

/***/ }),

/***/ "./src/numbers.gram":
/*!**************************!*\
  !*** ./src/numbers.gram ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"model/numbers.gram\";\n\n//# sourceURL=webpack://soundswallower-demo/./src/numbers.gram?");

/***/ }),

/***/ "./src/pizza.gram":
/*!************************!*\
  !*** ./src/pizza.gram ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"model/pizza.gram\";\n\n//# sourceURL=webpack://soundswallower-demo/./src/pizza.gram?");

/***/ }),

/***/ "./src/processors.js":
/*!***************************!*\
  !*** ./src/processors.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"c5cc25f53ba39149a92d.js\";\n\n//# sourceURL=webpack://soundswallower-demo/./src/processors.js?");

/***/ }),

/***/ "?ea0c":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://soundswallower-demo/fs_(ignored)?");

/***/ }),

/***/ "?63ba":
/*!*****************************!*\
  !*** fs/promises (ignored) ***!
  \*****************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://soundswallower-demo/fs/promises_(ignored)?");

/***/ }),

/***/ "?d802":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://soundswallower-demo/path_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;